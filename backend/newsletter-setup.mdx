---
title: 'Newsletter Service ‚Äî Zoho Groups, Templates & Email Pipeline'
description: 'End-to-end guide to managing mailing groups in Zoho, creating SES templates, scheduling newsletters, and dispatching e-mail via SNS/SQS/Lambda'
---

# Newsletter Service Overview

This module lets admins:

1. **Create and manage Zoho Mail groups** (recipients live inside Zoho; metadata is mirrored in MongoDB).
2. **Design templates** with the **ShootMail SDK + Amazon SES**, store them in MongoDB, and optionally schedule them.
3. **Send newsletters** automatically through an SNS ‚Üí SQS ‚Üí Lambda fan-out.

<Callout emoji="üí°">
All endpoints are protected by the existing JWT middleware (not shown here).  
See the <Link to="/auth/overview">Auth guide</Link> for details.
</Callout>

---

## 1 Configuration

```typescript title="src/config/zohoGroupConfig.ts"
import dotenv from 'dotenv';
dotenv.config();

/* General */
export const PORT = 3000;

/* Zoho OAuth */
export const CLIENT_ID      = process.env.CLIENT_ID      ?? 'ZOHO_CLIENT_ID';
export const CLIENT_SECRET  = process.env.CLIENT_SECRET  ?? 'ZOHO_CLIENT_SECRET';
export const ZO_ID          = process.env.ZO_ID          ?? 'ZOHO_ORG_ID';
export const REDIRECT_URI   = process.env.REDIRECT_URI   ?? 'http://localhost:3000/zoho/callback';

export const ZOHO_OAUTH_AUTH_URL  = 'https://accounts.zoho.in/oauth/v2/auth';
export const ZOHO_OAUTH_TOKEN_URL = 'https://accounts.zoho.in/oauth/v2/token';

/* Scopes */
export const scopes = [
  'ZohoMail.organization.groups.CREATE',
  'ZohoMail.organization.groups.READ',
  'ZohoMail.organization.groups.UPDATE',
  'ZohoMail.organization.groups.DELETE',
  'ZohoMail.organization.accounts.CREATE',
  'ZohoMail.organization.accounts.READ',
  'ZohoMail.organization.accounts.UPDATE',
  'ZohoMail.organization.accounts.DELETE',
];
export const scopeParam = encodeURIComponent(scopes.join(','));
```


## 2 Zoho OAuth token lifecycle
<AccordionGroup>

  <Accordion title="üîë Initial bootstrap">
    <Steps>
      <Step title="Purpose">
        Generates the very first pair of credentials
        (<code>access_token</code> + <code>refresh_token</code>) for your Zoho
        organisation and stores them in MongoDB.
      </Step>

      <Step title="Flow">
        1. Build a Zoho consent URL with the correct scopes.  
        2. Admin opens the link, approves access, and is redirected with
           <code>?code=&lt;auth-code&gt;</code>.  
        3. The CLI script exchanges that code for tokens using the Zoho OAuth
           <code>/token</code> endpoint.  
        4. Existing token documents are purged, then the new token set is saved
           as a single row in <code>ZohoOrgTokenModel</code>.
      </Step>

      <Step title="When to run">
        Only once per environment, or when you intentionally revoke the existing
        refresh token inside the Zoho UI.
      </Step>
    </Steps>

</Accordion>
</AccordionGroup>
```typescript title="utils/ZohoGroupService/addAccessTokenScript.ts"
    import readline from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import mongoose  from 'mongoose';
import axios     from 'axios';
import {
  CLIENT_ID, CLIENT_SECRET, REDIRECT_URI,
  ZOHO_OAUTH_AUTH_URL, ZOHO_OAUTH_TOKEN_URL, scopeParam,
} from '../../src/config/zohoGroupConfig';
import { ZohoOrgTokenModel } from '@fit-earn-meditate/backend-shared-models';

(async () => {
  await mongoose.connect(process.env.MONGO_URI!);

  /* 1Ô∏è‚É£ ask user to approve */
  const consent =
    `${ZOHO_OAUTH_AUTH_URL}?client_id=${CLIENT_ID}` +
    `&response_type=code&access_type=offline` +
    `&redirect_uri=${encodeURIComponent(REDIRECT_URI)}` +
    `&scope=${scopeParam}`;

  console.log('\nOpen in browser and approve:\n', consent);

  const rl   = readline.createInterface({ input, output });
  const code = await rl.question('\nPaste Zoho ?code= here ‚ûú ');
  rl.close();

  if (!code) {
    console.error('No code provided. Abort.');
    process.exit(1);
  }

  /* 2Ô∏è‚É£ exchange for tokens */
  const { data } = await axios.post(ZOHO_OAUTH_TOKEN_URL, null, {
    params: {
      code,
      client_id    : CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri : REDIRECT_URI,
      grant_type   : 'authorization_code',
    },
  });

  /* 3Ô∏è‚É£ persist (replace any old row) */
  await ZohoOrgTokenModel.deleteMany({});
  await ZohoOrgTokenModel.create({
    accessToken : data.access_token,
    refreshToken: data.refresh_token,
    expiresAt   : new Date(Date.now() + data.expires_in * 1000),
  });

  console.log('‚úÖ  Org token saved');
  process.exit(0);
})();
```

<Steps> 
    <Step title="Purpose"> Keeps the stored <code>access_token</code> valid forever by refreshing it with the long-lived <code>refresh_token</code>. </Step>
    <Step title="Logic">
    * Checks the current document in <code>ZohoOrgTokenModel</code>.  
    * If <code>expiresAt ‚Äì now&nbsp;&lt;&nbsp;120 s</code> it calls
      <code>/token?grant_type=refresh_token</code>.  
    * Updates <code>accessToken</code> and <code>expiresAt</code> in place.  
    * Returns the fresh token so callers can attach it to API requests.
  </Step>

  <Step title="Usage pattern">
    Every helper that talks to Zoho imports
    <code>getValidOrgAccessToken()</code>; no controller ever touches the
    database directly.
  </Step>
</Steps>
    
## 3 Zoho HTTP helper

`zohoRequest` is a lightweight wrapper around **Axios** that injects a fresh
organisation access-token into every call and lets callers decide how to handle
non-2xx status codes. The companion `orgUrl()` helper builds the base URL for
any Zoho Mail Organisation API path.

```typescript title="utils/ZohoGroupService/zohoService.ts"
import axios, { AxiosResponse } from 'axios';
import { getValidOrgAccessToken } from './orgTokenStore';
import { ZO_ID } from '../../config/zohoGroupConfig';

/**
 * Generic request helper for the Zoho Organisation Mail API.
 *
 * @param method - HTTP verb
 * @param url    - full URL or `orgUrl('/path')`
 * @param data   - optional JSON body / query
 */
export async function zohoRequest<T>(
  method: 'get' | 'post' | 'put' | 'delete',
  url: string,
  data?: unknown,
): Promise<AxiosResponse<T>> {
  const accessToken = await getValidOrgAccessToken();

  return axios<T>({
    method,
    url,
    data,
    headers: {
      Authorization: `Zoho-oauthtoken ${accessToken}`,
      'Content-Type': 'application/json',
    },
    // always resolve; caller inspects status.code
    validateStatus: () => true,
  });
}

/** Convenience builder for any /api/organization endpoint */
export const orgUrl = (path: string) =>
  `https://mail.zoho.in/api/organization/${ZO_ID}/${path}`;
```






## 4 Group-management endpoints
<AccordionGroup>
    <Accordion title="‚ûï Create group `POST /admin/groups`">
        <Steps>
        <Step title="What it does">
            Creates a Zoho Mail group, then mirrors the new group in
            <code>NewsletterGroup</code>.
        </Step>
        <Step title="Happy-path flow">
            <>
            1. Call Zoho <code>/groups&nbsp;(POST)</code>.<br />
            2. If Zoho returns <code>201</code>, upsert the document locally.<br />
            3. Respond with Zoho‚Äôs payload.
            </>
        </Step>
        </Steps>

    </Accordion> 
    ```typescript title="controllers/Admin/createGroup.ts"
        import { Request, Response, NextFunction } from 'express';
        import { zohoRequest, orgUrl }             from '../../../utils/ZohoGroupService/zohoService';
        import { NewsletterGroup }                 from '@fit-earn-meditate/backend-shared-models';

        export async function createGroup(
        req: Request, res: Response, next: NextFunction,
        ) {
        try {
            const { name, emailId, description = '' } = req.body;

            /* 1 create in Zoho */
            const { data: zohoGroup } = await zohoRequest(
            'post',
            orgUrl('groups'),
            { name, emailId },
            );

            if (zohoGroup.status.code !== 201)
            return res.status(zohoGroup.status.code).json(zohoGroup);

            /* 2 mirror locally */
            await NewsletterGroup.findOneAndUpdate(
            { zohoID: zohoGroup.data.zgid },
            {
                groupName       : zohoGroup.data.name,
                groupDescription: description,
                groupEmail      : zohoGroup.data.emailId,
                zohoID          : zohoGroup.data.zgid,
            },
            { new: true, upsert: true, setDefaultsOnInsert: true },
            );

            return res.json({ zoho: zohoGroup });
        } catch (err) {
            next(err);
        }
        }
```

    <Accordion title="üë• Add members `PUT /admin/groups/:zgid/members`"> 
        <Steps> 
            <Step title="What it does"> 
                Adds one or more members to a Zoho group and appends them in MongoDB. 
            </Step> 
        </Steps>
    </Accordion>
        ```typescript title="controllers/Admin/addMember.ts"
            import { Request, Response, NextFunction } from 'express';
            import { zohoRequest, orgUrl }             from '../../../utils/ZohoGroupService/zohoService';
            import { NewsletterGroup }                 from '@fit-earn-meditate/backend-shared-models';

            export async function addGroupMembers(
            req: Request, res: Response, next: NextFunction,
            ) {
            try {
                const { zgid } = req.params;
                const { mailGroupMemberList, membersNames = [] } = req.body;

                /* 1 Zoho add */
                const { data: zohoResp } = await zohoRequest(
                'put',
                orgUrl(`groups/${zgid}`),
                { mode: 'addMailGroupMember', mailGroupMemberList },
                );

                /* 2 mirror locally */
                const now  = new Date();
                const docs = mailGroupMemberList.map(
                (m: { memberEmailId: string }, i: number) => ({
                    memberName : membersNames[i] ?? m.memberEmailId.split('@')[0],
                    memberEmail: m.memberEmailId,
                    dateJoined : now,
                }),
                );

                await NewsletterGroup.updateOne(
                { zohoID: Number(zgid) },
                { $addToSet: { groupMembers: { $each: docs } } },
                );

                return res.json(zohoResp);
            } catch (err) {
                next(err);
            }
            }
            ```
    <Accordion title="üóëÔ∏è Delete groups `DELETE /admin/groups`"> 
        <Steps> 
            <Step title="What it does"> 
                Bulk-deletes groups in Zoho and removes matching records from MongoDB. 
            </Step> 
        </Steps>
    </Accordion>
        ```typescript title="controllers/Admin/deleteGroup.ts"
            import { Request, Response, NextFunction } from 'express';
            import { zohoRequest, orgUrl }             from '../../../utils/ZohoGroupService/zohoService';
            import { NewsletterGroup }                 from '@fit-earn-meditate/backend-shared-models';

            export async function deleteGroups(
            req: Request, res: Response, next: NextFunction,
            ) {
            try {
                const { groupNames } = req.body as { groupNames?: string[] };
                if (!Array.isArray(groupNames) || groupNames.length === 0)
                return res.status(400).json({ error: 'groupNames must be non-empty array' });

                /* 1 list all groups */
                const { data: list } = await zohoRequest<{ data:{ groups:{zgid:number;name:string}[] } }>(
                'get',
                orgUrl('groups'),
                );

                const zgids = list.data.groups
                .filter(g => groupNames.includes(g.name))
                .map(g => g.zgid);

                if (zgids.length === 0)
                return res.json({ message: 'No matching groups in Zoho', groupNames });

                /* 2 delete in Zoho */
                await zohoRequest('delete', orgUrl('groups'), { groupList: zgids });

                /* 3 purge local */
                const { deletedCount } = await NewsletterGroup.deleteMany({ zohoID: { $in: zgids } });

                return res.json({ deletedZoho: zgids.length, deletedMongo: deletedCount });
            } catch (err) {
                next(err);
            }
            }
        ```

    <Accordion title="üîç Filter group members `GET /admin/groups/filter`">
        <Steps>
            <Step title="What it does">
            Returns a paginated, searchable list of group members across Zoho groups, filtered by group name, date range, or keyword match.
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Parse query parameters: `page`, `limit`, `search`, `groups`, `start`, `end`.<br />
                2. Build a MongoDB aggregation pipeline with `$unwind`, `$match`, `$project`, `$sort`, and `$facet` stages.<br />
                3. Execute the pipeline on the `NewsletterGroup` collection.<br />
                4. Return paginated results with metadata: `page`, `limit`, `total`, `pages`, and `entries`.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/filterAllMember.ts"
        import { Request, Response, NextFunction } from 'express';
        import { PipelineStage } from 'mongoose';
        import { NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';

        export async function filterGroupMembers(
            req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const page = Math.max(1, parseInt(req.query.page as string) || 1);
            const limit = Math.max(1, parseInt(req.query.limit as string) || 50);
            const skip = (page - 1) * limit;

            const search = ((req.query.search as string) ?? '').trim();

            const groupNames = ((req.query.groups as string) ?? '')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean);

            const startDate = req.query.start ? new Date(req.query.start as string) : null;
            const endDate = req.query.end ? new Date(req.query.end as string) : null;

            const and: Record<string, any>[] = [];

            if (search) {
                const regex = new RegExp(
                search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
                'i',
                );
                and.push({
                $or: [
                    { 'groupMembers.memberName': regex },
                    { 'groupMembers.memberEmail': regex },
                    { groupName: regex },
                    { groupEmail: regex },
                ],
                });
            }

            if (groupNames.length) {
                and.push({ groupName: { $in: groupNames } });
            }

            if (startDate || endDate) {
                const range: Record<string, any> = {};
                if (startDate) range.$gte = startDate;
                if (endDate) range.$lte = endDate;
                and.push({ 'groupMembers.dateJoined': range });
            }

            const matchStage = and.length ? ({ $match: { $and: and } } as PipelineStage.Match) : null;

            const pipeline: PipelineStage[] = [
                { $unwind: { path: '$groupMembers' } },
                ...(matchStage ? [matchStage] : []),
                {
                $project: {
                    _id: 0,
                    memberName: '$groupMembers.memberName',
                    memberEmail: '$groupMembers.memberEmail',
                    groupName: '$groupName',
                    groupEmail: '$groupEmail',
                    zohoID: '$zohoID',
                    dateJoined: '$groupMembers.dateJoined',
                },
                },
                { $sort: { memberName: 1 } },
                {
                $facet: {
                    data: [{ $skip: skip }, { $limit: limit }],
                    total: [{ $count: 'count' }],
                },
                },
            ];

            const [{ data, total }] = await NewsletterGroup.aggregate(pipeline);
            const totalCount = total[0]?.count ?? 0;

            return res.json({
                page,
                limit,
                total: totalCount,
                pages: Math.ceil(totalCount / limit),
                entries: data,
            });
            } catch (err) {
            next(err);
            }
        }
    ```



    <Accordion title="üìã Get all group members `GET /admin/groups/all`">
        <Steps>
            <Step title="What it does">
            Retrieves a paginated list of all group members across Zoho groups, with optional search functionality.
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Parse query parameters: `page`, `limit`, `search`.<br />
                2. Construct a MongoDB aggregation pipeline with `$unwind`, optional `$match`, `$project`, `$sort`, and `$facet` stages.<br />
                3. Execute the pipeline on the `NewsletterGroup` collection.<br />
                4. Return paginated results with metadata: `page`, `limit`, `total`, `pages`, and `entries`.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/getAllGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import { PipelineStage } from 'mongoose';
        import { NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';

        export async function getAllGroupMembers(
            req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const page = Math.max(1, parseInt(req.query.page as string) || 1);
            const limit = Math.max(1, parseInt(req.query.limit as string) || 50);
            const search = ((req.query.search as string) ?? '').trim();
            const skip = (page - 1) * limit;

            const match: Record<string, any> = {};
            if (search) {
                const regex = new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                match.$or = [
                { 'groupMembers.memberName': regex },
                { 'groupMembers.memberEmail': regex },
                { groupName: regex },
                { groupEmail: regex },
                ];
            }

            const pipeline: PipelineStage[] = [
                { $unwind: { path: '$groupMembers' } },
                ...(search ? [{ $match: match }] : []),
                {
                $project: {
                    _id: 0,
                    memberName: '$groupMembers.memberName',
                    memberEmail: '$groupMembers.memberEmail',
                    groupName: '$groupName',
                    groupEmail: '$groupEmail',
                    zohoID: '$zohoID',
                    dateJoined: '$groupMembers.dateJoined',
                },
                },
                { $sort: { memberName: 1 } },
                {
                $facet: {
                    data: [{ $skip: skip }, { $limit: limit }],
                    total: [{ $count: 'count' }],
                },
                },
            ];

            const [{ data, total }] = await NewsletterGroup.aggregate(pipeline);
            const totalCount = total[0]?.count ?? 0;

            return res.json({
                page,
                limit,
                total: totalCount,
                pages: Math.ceil(totalCount / limit),
                entries: data,
            });
            } catch (err) {
            next(err);
            }
        }
    ```



    <Accordion title="üìß Get group email by ID `GET /admin/groups/:zgid/email`">
        <Steps>
            <Step title="What it does">
            Retrieves the primary email address (`emailId`) of a specific Zoho Mail group using its Zoho Group ID (`zgid`).
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Extract the `zgid` parameter from the request URL.<br />
                2. Make a `GET` request to Zoho's API endpoint: `/groups/{zgid}`.<br />
                3. If the response contains an `emailId`, return it in the response.<br />
                4. If the `emailId` is missing or the group is not found, return a `404` error with an appropriate message.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/getGroupEmail.ts"
        import { Request, Response, NextFunction } from 'express';
        import { zohoRequest, orgUrl } from '../../../utils/ZohoGroupService/zoho.service';

        interface GroupDetailsResponse {
            data: { emailId?: string };
        }

        export async function getGroupEmail(
            req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const { zgid } = req.params;

            const { data: group } = await zohoRequest<GroupDetailsResponse>(
                'get',
                orgUrl(`groups/${zgid}`),
            );

            const emailId = group.data?.emailId;
            if (!emailId) {
                return res
                .status(404)
                .json({ message: 'Group not found or missing emailId.' });
            }

            return res.json({ emailId });
            } catch (err: any) {
            console.error('[getGroupEmail] error:', err.response?.data || err.message);
            return res.status(500).json(err.response?.data || err.message);
            }
        }
        ```



    <Accordion title="üë• Get groups by member `GET /admin/groups/member/:identifier`">
        <Steps>
            <Step title="What it does">
            Retrieves all newsletter groups that a specific member belongs to, identified by their email address or name.
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Extract the `identifier` parameter from the request URL.<br />
                2. Query the `NewsletterGroup` collection to find groups where a member's email or name matches the identifier.<br />
                3. For each matching group, extract relevant details including group name, description, email, and the member's join date.<br />
                4. Format the `dateJoined` to the 'Asia/Kolkata' timezone using Moment.js.<br />
                5. Return the list of groups with the associated member details.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/getGroupsByMember.ts"
        import { Request, Response, NextFunction } from 'express';
        import { NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';
        import moment from 'moment-timezone';

        export async function getGroupsByMember(
            req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const { identifier } = req.params;

            if (!identifier) {
                return res.status(400).json({ error: 'identifier param is required' });
            }

            const rawGroups = await NewsletterGroup.find({
                groupMembers: {
                $elemMatch: {
                    $or: [
                    { memberEmail: identifier },
                    { memberName: new RegExp(`^${identifier}$`, 'i') },
                    ],
                },
                },
            }).select('groupName groupDescription groupEmail groupMembers');

            if (!rawGroups.length) {
                return res
                .status(404)
                .json({ message: 'No groups found for that member', identifier });
            }

            const groups = rawGroups.map((g) => {
                const member = g.groupMembers.find(
                (m) =>
                    m.memberEmail === identifier ||
                    m.memberName?.toLowerCase() === identifier.toLowerCase(),
                );

                return {
                groupName: g.groupName,
                groupDescription: g.groupDescription,
                groupEmail: g.groupEmail,
                dateJoined: member
                    ? moment(member.dateJoined).tz('Asia/Kolkata').format()
                    : null,
                };
            });

            return res.json(groups);
            } catch (err) {
            next(err);
            }
        }
        ```



    <Accordion title="üîç Get Zoho Group ID `GET /admin/groups/zoho-id`">
        <Steps>
            <Step title="What it does">
            Retrieves the Zoho Group ID (`zohoID`) for a newsletter group based on the provided `groupName` or `groupEmail`.
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Extract `groupName` and `groupEmail` from the query parameters.<br />
                2. Construct a query object using the provided parameters.<br />
                3. Use Mongoose's `findOne` method to search the `NewsletterGroup` collection for a matching document.<br />
                4. If a matching group is found, return its `zohoID`.<br />
                5. If no matching group is found, respond with a 404 error indicating that the group was not found.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/getZohoGroupID.ts"
        import { Request, Response, NextFunction } from 'express';
        import { NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';

        export async function getZohoGroupID(
            req: Request,
            res: Response,
            next: NextFunction
        ) {
            try {
            const { groupName, groupEmail } = req.query;

            if (!groupName && !groupEmail) {
                return res.status(400).json({ error: 'Provide groupName or groupEmail' });
            }

            const query: any = {};
            if (groupName) query.groupName = groupName;
            if (groupEmail) query.groupEmail = groupEmail;

            const group = await NewsletterGroup.findOne(query).select('zohoID');

            if (!group) {
                return res.status(404).json({ error: 'Group not found' });
            }

            return res.json({ zohoID: group.zohoID });
            } catch (err) {
            next(err);
            }
        }
    ```


    <Accordion title="üìã List Groups `GET /admin/groups`">
        <Steps>
            <Step title="What it does">
            Retrieves a list of all groups in the Zoho organization using the Zoho Mail API.
            </Step>
            <Step title="Happy-path flow">
            <>
                1. Sends a GET request to Zoho's `/groups` endpoint.<br />
                2. Parses the response to extract group details.<br />
                3. Returns the list of groups to the client.
            </>
            </Step>
        </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/listGroups.ts"
        import { Request, Response, NextFunction } from 'express';
        import { zohoRequest, orgUrl } from '../../../utils/ZohoGroupService/zoho.service';

        interface ListGroupsRes {
            data: {
            groups: {
                zgid: number;
                name: string;
                emailId: string;
                displayName?: string;
            }[];
            };
        }

        export async function listGroups(
            _req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const { data } = await zohoRequest<ListGroupsRes>('get', orgUrl('groups'));
            return res.json(data.data.groups);
            } catch (err) {
            next(err);
            }
        }
    ```


    <Accordion title="üë• Remove Group Members `PUT /admin/groups/:zgid/remove-members`">
    <Steps>
        <Step title="What it does">
        Removes specified members from a Zoho Mail group and updates the local MongoDB to reflect these changes.
        </Step>
        <Step title="Happy-path flow">
        <>
            1. Sends a PUT request to Zoho's `/groups/{zgid}` endpoint with `mode: deleteMailGroupMember` and the list of members to remove.<br />
            2. Upon successful removal from Zoho, updates the corresponding group document in MongoDB to remove the specified members.<br />
            3. Returns the response from Zoho and the result of the MongoDB update to the client.
        </>
        </Step>
    </Steps>
    </Accordion>

        ```typescript title="controllers/Admin/removeGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import { zohoRequest, orgUrl } from '../../../utils/ZohoGroupService/zoho.service';
        import { NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';

        export async function removeGroupMembers(
            req: Request,
            res: Response,
            next: NextFunction,
        ) {
            try {
            const { zgid } = req.params;
            const { mailGroupMemberList } = req.body;

            if (!Array.isArray(mailGroupMemberList) || mailGroupMemberList.length === 0) {
                return res.status(400).json({ error: 'mailGroupMemberList must be a non-empty array' });
            }

            // 1. Remove members from Zoho group
            const { data: zohoResp } = await zohoRequest(
                'put',
                orgUrl(`groups/${zgid}`),
                {
                mode: 'deleteMailGroupMember',
                mailGroupMemberList,
                }
            );

            // 2. Extract email addresses to remove
            const emailsToRemove: string[] = mailGroupMemberList.map(
                (m: any) => m.memberEmailId ?? m.email ?? m.memberEmail,
            );

            // 3. Update MongoDB to remove members
            const mongoResult = await NewsletterGroup.updateOne(
                { zohoID: Number(zgid) },
                { $pull: { groupMembers: { memberEmail: { $in: emailsToRemove } } } },
            );

            return res.json({
                zoho: zohoResp,
                mongo: { modifiedCount: mongoResult.modifiedCount },
            });
            } catch (err) {
            next(err);
            }
        }
    ```




</AccordionGroup> 

















## 5. Template Creation & (Optional) Auto-Scheduling
<AccordionGroup> 
    <Accordion title="üìÑ `POST /admin/templates`"> 
    <Steps> 
        <Step title="Create SES template"> 
            Calls <code>CreateEmailTemplateCommand</code>. Handles duplicate-name clash. 
        </Step> 
        <Step title="Save template in MongoDB"> 
        Persists HTML, category, etc. 
    </Step> 
    <Step title="(Optional) Auto-schedule"> 
    If <code>groupOfUserSend + scheduledDate + scheduledTime</code> are provided, rewrites <code>state</code> to <code>scheduled</code> and adds a <code>ScheduledJobModel</code> document. 
    </Step> 
    </Steps>
    </Accordion>





    <Accordion title="üìß Create Email Template `POST /admin/templates`">
        <Steps>
            <Step title="What it does">
            Creates a new email template in AWS SES, stores its metadata in MongoDB, and optionally schedules it for future dispatch.
            </Step>
            <Step title="Request Body">
            The API expects a JSON object with the following fields:

            - `name` (string, required): Unique identifier for the template.
            - `contentHTML` (string, required): HTML content of the email.
            - `subject` (string, optional): Subject line of the email. Defaults to 'Default Subject' if not provided.
            - `createdBy` (string, required): Identifier of the user creating the template.
            - `category` (string, required): Category classification for the template.
            - `title` (string, required): Title of the template.
            - `type` (string, required): Type of the template (e.g., 'newsletter', 'promotion').
            - `groupOfUserSend` (string, required): Name of the user group to send the email to.
            - `scheduledDate` (string, optional): Date when the email should be sent (format: 'YYYY-MM-DD').
            - `scheduledTime` (string, optional): Time when the email should be sent (format: 'HH:mm').
            - `state` (string, optional): State of the template (e.g., 'draft', 'scheduled').
            - `userGroup` (string, optional): Additional user group information.
            </Step>
            <Step title="Responses">
            - `201 Created`: Template successfully created in AWS SES and MongoDB.
            - `400 Bad Request`: Missing required fields or invalid data.
            - `404 Not Found`: Specified user group not found.
            - `409 Conflict`: Template with the given name already exists in AWS SES.
            - `500 Internal Server Error`: An unexpected error occurred.
            </Step>
        </Steps>
    </Accordion>

    ```typescript title="controllers/Admin/removeGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import {
        SESv2Client,
        CreateEmailTemplateCommand,
        CreateEmailTemplateCommandInput,
        } from '@aws-sdk/client-sesv2';
        import moment from 'moment-timezone';
        import { TemplateModel, NewsletterGroup } from '@fit-earn-meditate/backend-shared-models';

        if (!process.env.AWS_ACCESS_KEY_ID1 || !process.env.AWS_SECRET_ACCESS_KEY1) {
        throw new Error('AWS credentials are missing in environment variables');
        }

        const sesClient = new SESv2Client({
        region: process.env.AWS_REGION || 'ap-south-1',
        credentials: {
            accessKeyId: process.env.AWS_ACCESS_KEY_ID1 as string,
            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY1 as string,
        },
        });

        interface CustomRequest extends Request {
        generatedId?: string;
        }

        export async function createTemplate(
        req: CustomRequest,
        res: Response,
        next: NextFunction,
        ) {
        try {
            const {
            name,
            contentHTML,
            subject = 'Default Subject',
            createdBy,
            category,
            title,
            type,
            groupOfUserSend,
            scheduledDate,
            scheduledTime,
            state,
            userGroup,
            } = req.body;

            if (!name || !contentHTML || !createdBy || !category || !title || !type || !groupOfUserSend) {
            return res.status(400).json({
                error:
                'Fields "name", "contentHTML", "createdBy", "category", "title", "type", "groupOfUserSend" are required.',
            });
            }

            const sesParams: CreateEmailTemplateCommandInput = {
            TemplateName: name,
            TemplateContent: {
                Html: contentHTML,
                Text: 'Plain text fallback',
                Subject: subject,
            },
            };

            try {
            await sesClient.send(new CreateEmailTemplateCommand(sesParams));
            } catch (err: any) {
            if (err.name === 'TemplateNameAlreadyExistsException') {
                return res.status(409).json({ error: `Template '${name}' already exists in SES.` });
            }
            throw err;
            }

            const TEMPLATE_ID = req.generatedId;

            const templateDoc = new TemplateModel({
            createdBy,
            category,
            title,
            type,
            groupOfUserSend,
            name,
            contentHTML,
            scheduledDate,
            scheduledTime,
            state,
            userGroup,
            newsLetterID: TEMPLATE_ID,
            });

            await templateDoc.save();

            if (groupOfUserSend && scheduledDate && scheduledTime) {
            const group = await NewsletterGroup.findOne({ groupName: groupOfUserSend });
            if (!group) {
                return res.status(404).json({ error: `Group '${groupOfUserSend}' not found.` });
            }

            const sendAt = moment
                .tz(`${scheduledDate} ${scheduledTime}`, 'YYYY-MM-DD HH:mm', 'Asia/Kolkata')
                .utc();

            if (sendAt.isBefore(moment.utc())) {
                return res.status(400).json({ error: 'Scheduled time is in the past.' });
            }

            templateDoc.scheduledDate = sendAt.toDate();
            templateDoc.state = 'scheduled';
            await templateDoc.save();
            }

            return res.status(201).json({
            success: true,
            message: 'Template created in SES and MongoDB.',
            template: templateDoc,
            });
        } catch (err) {
            console.error('Error creating template:', err);
            next(err);
        }
        }
    ```



    <Accordion title="‚úèÔ∏è Update Email Template `PUT /admin/templates/:name`">
    <Steps>
        <Step title="What it does">
        Updates an existing email template in AWS SES and MongoDB. Allows modification of the email's subject, HTML content, and associated metadata such as category, title, type, user group, and scheduling details.
        </Step>
        <Step title="Path Parameter">
        - `name` (string, required): The unique name of the template to be updated.
        </Step>
        <Step title="Request Body">
        The API accepts a JSON object with the following optional fields:

        - `subject` (string): New subject line for the email.
        - `contentHTML` (string): Updated HTML content of the email.
        - `category` (string): Updated category classification for the template.
        - `title` (string): Updated title of the template.
        - `type` (string): Updated type of the template (e.g., 'newsletter', 'promotion').
        - `groupOfUserSend` (string): Updated name of the user group to send the email to.
        - `scheduledDate` (string): Updated date when the email should be sent (format: 'YYYY-MM-DD').
        - `scheduledTime` (string): Updated time when the email should be sent (format: 'HH:mm').
        - `state` (string): Updated state of the template (e.g., 'draft', 'scheduled').
        - `userGroup` (string): Updated additional user group information.

        **Note:** At least one of `subject` or `contentHTML` must be provided to update the SES template.
        </Step>
        <Step title="Responses">
        - `200 OK`: Template successfully updated in AWS SES and MongoDB.
        - `400 Bad Request`: Neither `subject` nor `contentHTML` provided for SES update.
        - `404 Not Found`: Template with the specified name not found.
        - `500 Internal Server Error`: An unexpected error occurred during the update process.
        </Step>
    </Steps>
    </Accordion>
    ```typescript title="controllers/Admin/removeGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import {
        SESv2Client,
        UpdateEmailTemplateCommand,
        UpdateEmailTemplateCommandInput,
        } from '@aws-sdk/client-sesv2';
        import { TemplateModel } from '@fit-earn-meditate/backend-shared-models'; 
        import dotenv from 'dotenv';

        dotenv.config();


        if (!process.env.AWS_ACCESS_KEY_ID1 || !process.env.AWS_SECRET_ACCESS_KEY1) {
        throw new Error('AWS credentials are missing in environment variables');
        }

        const sesClient = new SESv2Client({
        region: process.env.AWS_REGION || 'ap-south-1',
        credentials: {
            accessKeyId: process.env.AWS_ACCESS_KEY_ID1 as string,
            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY1 as string,
        },
        });


        export async function updateTemplate(
        req: Request,
        res: Response,
        next: NextFunction,
        ) {
        try {
            const templateName = req.params.name;
            const {
            subject,
            contentHTML,
            category,
            title,
            type,
            groupOfUserSend,
            scheduledDate,
            scheduledTime,
            state,
            userGroup,
            } = req.body;

            const existingDoc = await TemplateModel.findOne({ name: templateName });
            if (!existingDoc) {
            return res.status(404).json({ error: `Template '${templateName}' not found.` });
            }

            if (!subject && !contentHTML) {
            return res.status(400).json({
                error: 'Provide at least one of "subject" or "contentHTML" to update SES.',
            });
            }

            const sesParams: UpdateEmailTemplateCommandInput = {
            TemplateName: templateName,
            TemplateContent: {
                Html: contentHTML ?? existingDoc.contentHTML,
                Text: 'Plain text fallback', 
                Subject: subject ?? 'Default Subject', 
            },
            };

            await sesClient.send(new UpdateEmailTemplateCommand(sesParams));

            const updateFields: Record<string, any> = {};
            if (subject        !== undefined) updateFields.subject         = subject;
            if (contentHTML    !== undefined) updateFields.contentHTML     = contentHTML;
            if (category       !== undefined) updateFields.category        = category;
            if (title          !== undefined) updateFields.title           = title;
            if (type           !== undefined) updateFields.type            = type;
            if (groupOfUserSend!== undefined) updateFields.groupOfUserSend = groupOfUserSend;
            if (scheduledDate  !== undefined) updateFields.scheduledDate   = scheduledDate;
            if (scheduledTime  !== undefined) updateFields.scheduledTime   = scheduledTime;
            if (state          !== undefined) updateFields.state           = state;
            if (userGroup      !== undefined) updateFields.userGroup       = userGroup;

            const updatedDoc = await TemplateModel.findOneAndUpdate(
            { name: templateName },
            { $set: updateFields },
            { new: true },
            );

            return res.json({
            success: true,
            message: `Template '${templateName}' updated in SES and MongoDB.`,
            template: updatedDoc,
            });
        } catch (err) {
            console.error('Error updating template:', err);
            next(err);
        }
        }
    ```



    <Accordion title="üóëÔ∏è Delete Email Template `DELETE /admin/templates/:name`">
    <Steps>
        <Step title="What it does">
        Deletes an email template from AWS SES and removes its corresponding metadata from MongoDB.
        </Step>
        <Step title="Path Parameters">
        - `name` (string, required): The unique name of the template to be deleted.
        </Step>
        <Step title="Responses">
        - `200 OK`: Template successfully deleted from both AWS SES and MongoDB.
        - `404 Not Found`: Template not found in MongoDB (SES deletion attempted).
        - `500 Internal Server Error`: An unexpected error occurred during the deletion process.
        </Step>
    </Steps>
    </Accordion>


```typescript title="controllers/Admin/removeGroupMembers.ts"
    import { Request, Response, NextFunction } from 'express';
    import {
    SESv2Client,
    DeleteEmailTemplateCommand,
    DeleteEmailTemplateCommandInput,
    } from '@aws-sdk/client-sesv2';
    import { TemplateModel } from '@fit-earn-meditate/backend-shared-models';
    import dotenv from 'dotenv';

    dotenv.config();

    if (!process.env.AWS_ACCESS_KEY_ID1 || !process.env.AWS_SECRET_ACCESS_KEY1) {
    throw new Error('AWS credentials are missing in environment variables');
    }

    const sesClient = new SESv2Client({
    region: process.env.AWS_REGION || 'ap-south-1',
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID1 as string,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY1 as string,
    },
    });


    export async function deleteTemplate(
    req: Request,
    res: Response,
    next: NextFunction,
    ) {
    try {
        const templateName = req.params.name;

        const sesParams: DeleteEmailTemplateCommandInput = {
        TemplateName: templateName,
        };

        try {
        await sesClient.send(new DeleteEmailTemplateCommand(sesParams));
        } catch (err: any) {
        if (err.name !== 'TemplateDoesNotExistException') {
            throw err;
        }
        }

        const mongoResult = await TemplateModel.findOneAndDelete({ name: templateName });

        if (!mongoResult) {
        return res.status(404).json({
            error: `Template '${templateName}' not found in MongoDB (SES deletion attempted).`,
        });
        }

        return res.json({
        success: true,
        message: `Template '${templateName}' deleted from SES and MongoDB.`,
        removedMongoDoc: mongoResult,  
        });
    } catch (err) {
        console.error('Error deleting template:', err);
        next(err);
    }
    }
    ```




    <Accordion title="üìÑ Get Email Template `GET /admin/templates`">
    <Steps>
        <Step title="What it does">
        Retrieves the metadata of an email template from MongoDB and its content from AWS SES based on the provided template name.
        </Step>
        <Step title="Query Parameters">
        - `templateName` (string, required): The unique name of the template to retrieve.
        </Step>
        <Step title="Responses">
        - `200 OK`: Returns the template's metadata and content.
        - `400 Bad Request`: Missing `templateName` query parameter.
        - `404 Not Found`: Template not found in MongoDB.
        - `500 Internal Server Error`: An unexpected error occurred during the retrieval process.
        </Step>
    </Steps>
    </Accordion>

    ```typescript title="controllers/Admin/removeGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import { SESv2Client, GetEmailTemplateCommand } from '@aws-sdk/client-sesv2';
        import {TemplateModel} from '@fit-earn-meditate/backend-shared-models';       
        import dotenv from 'dotenv';

        dotenv.config();


        const sesClient = new SESv2Client({
        region: process.env.AWS_REGION || 'ap-south-1',
        credentials: {
            accessKeyId: process.env.AWS_ACCESS_KEY_ID1 as string,
            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY1 as string,
        },
        });


        export async function getTemplate(
        req: Request,
        res: Response,
        next: NextFunction,
        ): Promise<void> {
        const { templateName } = req.query;

        if (!templateName) {
            res.status(400).json({ error: 'Missing "templateName" query param' });
            return;
        }

        try {
        
            const meta = await TemplateModel.findOne({ name: templateName as string }).lean();

            if (!meta) {
            res.status(404).json({ error: `Template '${templateName}' not found in DB` });
            return;
            }

        
            const command = new GetEmailTemplateCommand({
            TemplateName: templateName as string,
            });
            const sesData = await sesClient.send(command);

        
            res.status(200).json({
            templateName,
            meta,                            
            sesContent: {
                SubjectPart: sesData.TemplateContent?.Subject,
                TextPart   : sesData.TemplateContent?.Text,
                HtmlPart   : sesData.TemplateContent?.Html,
            },
            });
        } catch (error) {
            console.error('Error retrieving template:', error);
            res
            .status(500)
            .json({ error: `Failed to retrieve template '${templateName}'.` });
        }
        }
    ```



    <Accordion title="üìÑ Get All Templates `GET /admin/templates/all`">
    <Steps>
        <Step title="What it does">
        Retrieves a paginated list of email templates from MongoDB, optionally filtered by a search term.
        </Step>
        <Step title="Query Parameters">
        - `page` (number, optional): Page number for pagination (default: 1).
        - `limit` (number, optional): Number of templates per page (default: 50).
        - `search` (string, optional): A search keyword to filter templates by title or name.
        </Step>
        <Step title="Responses">
        - `200 OK`: Returns paginated template data with metadata.
        - `500 Internal Server Error`: If an unexpected error occurs during retrieval.
        </Step>
        <Step title="Example Response">
        ```json
        {
            "page": 1,
            "limit": 50,
            "total": 3,
            "pages": 1,
            "templates": [
            {
                "_id": "64f8332...",
                "name": "welcome_template",
                "title": "Welcome Email",
                "createdAt": "2024-09-01T10:00:00.000Z"
            }
            ]
        }
        ```
        </Step>
    </Steps>
    </Accordion>
    ```typescript title="controllers/Admin/removeGroupMembers.ts"
        import { Request, Response, NextFunction } from 'express';
        import {TemplateModel} from '@fit-earn-meditate/backend-shared-models';   


        export async function getAllTemplates(
        req: Request,
        res: Response,
        next: NextFunction,
        ) {
        try {

            const page   = Math.max(1, parseInt(req.query.page  as string) || 1);
            const limit  = Math.max(1, parseInt(req.query.limit as string) || 50);
            const skip   = (page - 1) * limit;
            const search = ((req.query.search as string) ?? '').trim();

            const filter: Record<string, any> = {};
            if (search) {
            const regex = new RegExp(
                search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
                'i',
            );
            filter.$or = [{ title: regex }, { name: regex }];
            }

            const [templates, total] = await Promise.all([
            TemplateModel.find(filter)
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(limit)
                .lean(),
            TemplateModel.countDocuments(filter),
            ]);

            return res.json({
            page,
            limit,
            total,
            pages: Math.ceil(total / limit),
            templates,         
            });
        } catch (err) {
            next(err);
        }
        }
    ```

    <Accordion title="üìÑ Schedule Newsletter `POST /admin/newsletter/schedule`">
    <Steps>
        <Step title="What it does">
        Schedules a newsletter to be sent at a future date and time by linking a template to a newsletter group.
        </Step>
        <Step title="Request Body">
        - `templateName` (string, required): The name of the template to use.
        - `groupName` (string, required): The name of the newsletter group to send to.
        - `date` (string, required): Date in `YYYY-MM-DD` format.
        - `time` (string, required): Time in `HH:mm` (24-hour) format (Asia/Kolkata timezone).
        </Step>
        <Step title="Responses">
        - `201 Created`: Newsletter is successfully scheduled.
        - `400 Bad Request`: Missing required fields or scheduled time is in the past.
        - `404 Not Found`: Specified template or group not found.
        - `500 Internal Server Error`: If an unexpected error occurs.
        </Step>
        <Step title="Example Request Body">
        ```json
        {
            "templateName": "new_year_offer",
            "groupName": "subscribers_2024",
            "date": "2025-01-01",
            "time": "10:00"
        }
        ```
        </Step>
        <Step title="Example Success Response">
        ```json
        {
            "success": true,
            "message": "Newsletter scheduled.",
            "sendAt": "2025-01-01T04:30:00.000Z"
        }
        ```
        </Step>
    </Steps>
    </Accordion>


    ```typescript title="controllers/Admin/removeGroupMembers.ts"
            import { Request, Response, NextFunction } from 'express';
        import moment from 'moment-timezone';
        import {TemplateModel} from '@fit-earn-meditate/backend-shared-models';        
        import {NewsletterGroup} from '@fit-earn-meditate/backend-shared-models';
        import {ScheduledJobModel} from '@fit-earn-meditate/backend-shared-models';
        import { Types } from 'mongoose';

        interface Body {
        templateName : string;   
        groupName    : string;   
        date         : string;   
        time         : string;  
        }

        export async function scheduleNewsletter(
        req: Request<{}, {}, Body>,
        res: Response,
        next: NextFunction,
        ) {
        try {
            const { templateName, groupName, date, time } = req.body;

            if (!templateName || !groupName || !date || !time) {
            return res.status(400).json({
                error: '"templateName", "groupName", "date", "time" are required.',
            });
            }

            const [template, group] = await Promise.all([
            TemplateModel.findOne({ name: templateName }),
            NewsletterGroup.findOne({ groupName }),
            ]);

            if (!template) return res.status(404).json({ error: 'Template not found.' });
            if (!group) return res.status(404).json({ error: 'Group not found.' });

            
            const sendAt = moment.tz(`${date} ${time}`, 'YYYY-MM-DD HH:mm', 'Asia/Kolkata').utc();

            if (sendAt.isBefore(moment.utc())) {
            return res.status(400).json({ error: 'Scheduled time is in the past.' });
            }

            template.scheduledDate = sendAt.toDate();
            template.state = 'scheduled';
            await template.save();

            await ScheduledJobModel.create({
            template: template._id,
            group: group._id,
            groupEmail: group.groupEmail,
            sendAt: sendAt.toDate(), 
            state: 'scheduled',
            });

            return res.status(201).json({
            success: true,
            message: 'Newsletter scheduled.',
            sendAt: sendAt.format(),
            });
        } catch (err) {
            next(err);
        }
        }
    ```


    
</AccordionGroup>






















## 6 Dispatch Pipeline (SNS ‚Üí SQS ‚Üí Lambda)

<Callout emoji="üöÄ">
This section documents the production notification stack:
<strong>Lambda function</strong> <code>notificationPOC-dev-be</code>,  
<strong>SQS queues</strong> <code>EmailNotificationQueue</code> / <code>EmailNotificationDLQ</code>,  
and <strong>SNS topic</strong> <code>EmailNotificationSNS</code>.
</Callout>

### 6.1 High-level architecture
<Accordion title="üì¨ Email Notification Flow: SNS ‚Üí SQS ‚Üí Lambda ‚Üí SES with DLQ">
  <Steps>
    <Step title="Overview">
      This flow outlines a resilient architecture for handling email notifications using AWS services:
      - **SNS**: Receives JSON payloads from the application.
      - **SQS**: Acts as a buffer, decoupling the application from downstream processing.
      - **Lambda**: Processes messages from SQS, logs them to MongoDB, and sends emails via SES.
      - **DLQ**: Captures messages that fail processing after a specified number of attempts.
    </Step>

    <Step title="Flow Details">
      1. **Application** publishes a JSON payload to an **SNS** topic.
      2. **SNS** delivers the message to an **SQS** queue subscribed to the topic.
      3. **Lambda** function is triggered by messages in the SQS queue:
         - Parses the JSON payload.
         - Logs the message to **MongoDB**.
         - Sends an email using **SES**.
      4. If the Lambda function fails to process a message after a defined number of retries (configured via `maxReceiveCount`), the message is moved to a **Dead Letter Queue (DLQ)** for further analysis.
    </Step>

    <Step title="Dead Letter Queue (DLQ) Configuration">
      - **Purpose**: Stores messages that couldn't be processed successfully after multiple attempts.
      - **Setup**:
        - Create an SQS queue to serve as the DLQ.
        - Configure the main SQS queue with a redrive policy specifying the DLQ and `maxReceiveCount`.
      - **Monitoring**:
        - Use **Amazon CloudWatch** to monitor the DLQ for incoming messages.
        - Set up alarms to notify when messages are moved to the DLQ.
      - **Processing DLQ Messages**:
        - Analyze and reprocess messages manually or set up another Lambda function to handle DLQ messages.
    </Step>

    <Step title="Benefits">
      - **Scalability**: Decouples components, allowing each to scale independently.
      - **Reliability**: Ensures messages are not lost and can be retried or analyzed if failures occur.
      - **Observability**: Facilitates monitoring and debugging through DLQ and CloudWatch integration.
    </Step>
  </Steps>
</Accordion>


### 6.2 Lambda handler (partial-batch, idempotent)
```typescript title="handler".ts"
    import { SQSEvent, Context }      from 'aws-lambda';
    import * as AWS                   from 'aws-sdk';
    import { MongoClient, MongoError } from 'mongodb';

    const ses = new AWS.SES({ region: 'ap-south-1' });
    const DB_URI = process.env.DB_CONNECTION_STRING!;
    let cachedClient: MongoClient | null = null;

    interface FailList { batchItemFailures: { itemIdentifier: string }[]; }

    export const handler = async (
    event: SQSEvent,
    _ctx : Context
    ): Promise<FailList> => {
    const failures: FailList['batchItemFailures'] = [];
    const db = await getDb();

    for (const rec of event.Records) {
        const dedupId = rec.messageId;
        try {
        const msg = JSON.parse(JSON.parse(rec.body).Message);
        await insertIfNew(db, dedupId, msg);

        if (msg.typeOfMail === 'customBulkMail')
            await sendCustomBulk(msg);
        else if (msg.typeOfMail === 'bulkMail')
            await sendGroupMail(msg);
        else
            throw new Error(`Unknown typeOfMail ${msg.typeOfMail}`);

        } catch (err) {
        console.error('record error', dedupId, err);
        failures.push({ itemIdentifier: dedupId });
        }
    }
    return { batchItemFailures: failures };
    };

    /* -------------- helpers --------------------- */
    async function getDb() {
    if (!cachedClient) {
        cachedClient = await new MongoClient(DB_URI).connect();
    }
    return cachedClient.db('myDatabase');
    }

    async function insertIfNew(db, dedupId, doc) {
    try {
        await db.collection('emailNotifications').insertOne({ dedupId, ...doc, ts: new Date() });
    } catch (e) {
        if ((e as MongoError).code === 11000) return; // duplicate
        throw e;
    }
    }

    async function sendCustomBulk(msg) {
    const dest = msg.recipients.map((e, i) => ({
        Destination: { ToAddresses: [e] },
        ReplacementTemplateData: JSON.stringify(msg.templateData[i] || {})
    }));
    await ses.sendBulkTemplatedEmail({
        Source: 'no-reply@yourdomain.com',
        Template: msg.templateName,
        Destinations: dest,
        DefaultTemplateData: '{}'
    }).promise();
    }

    async function sendGroupMail(msg) {
    await ses.sendTemplatedEmail({
        Source: 'no-reply@yourdomain.com',
        Destination: { ToAddresses: [msg.groupEmail] },
        Template: msg.templateName,
        TemplateData: '{}'
    }).promise();
    }
```


