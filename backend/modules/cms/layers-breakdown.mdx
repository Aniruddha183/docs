---
title: "CMS Lambda Layers Breakdown"
description: "Categorization of CMS Lambda functions based on infrastructure, domain ownership, cross-domain capabilities, and isolation rules."
---

# CMS Lambda Layers Breakdown

## Purpose

This document defines **how Lambda functions and utilities used by the CMS module are categorized** based on:

- Business meaning
- Domain ownership
- Sharing rules
- Isolation boundaries

It exists to ensure that:

- CMS domain logic does not leak into shared layers
- Infrastructure utilities remain business-agnostic
- Cross-domain capabilities are not incorrectly shared as helpers
- Future changes to CMS do not unintentionally impact other modules

This document answers:

> **“Where does a CMS-related function belong, and should it be shared?”**

---

## Layer A — Platform / Infra Layer (GLOBAL)

### Definition

Functions that provide **pure technical or infrastructure capabilities** and have **no knowledge of CMS concepts**, such as content, application type, permissions, or workflows.

These utilities do not know:

- What entity they operate on
- Why the operation exists
- Who is consuming the result

---

### Identification Rules

A function belongs to **Layer A** only if:

- It does not reference CMS entities (Content, FAQ, ApplicationType, etc.)
- It does not enforce CMS rules or validations
- It does not trigger business side effects
- It can be reused by **any module** without modification

---

### CMS Examples

- `logger`
- `responseHandler`
- `uploadImage` (raw upload only)
- `deleteImageFromS3`
- `uploadEncryptedDataToS3`
- `generatePresignedUrl`
- `decryptDataKeyWithKMS`

---

### Implementation Rules

- Implemented as **shared Lambda Layers**
- Versioned and reused across all backend modules
- Must remain backward compatible

---

## Layer B — CMS Domain Layer Utilities (DOMAIN-SPECIFIC)

### Definition

Functions that **encode CMS-specific knowledge**, rules, or behavior.

These utilities are meaningful **only inside the CMS domain**.

---

### Identification Rules

A function belongs to **Layer B** if it:

- Knows CMS entities (Content, FAQ, ContentType, ApplicationType)
- Applies CMS validations or constraints
- Shapes or transforms CMS data
- Enforces permission-dependent behavior
- Is used only by CMS APIs

---

### Key Rule

✅ **Duplication across domains is allowed**  
❌ **Sharing CMS domain utilities outside CMS is forbidden**

---

### CMS Examples

- `validateContentTypePayload`
- `validateApplicationType`
- `sanitizeContentPayload`
- `mapContentResponse`
- `filterContentByApplicationType`
- `prepareContentForPublicView`
- `mergeFaqUpdates`
- `extractCmsAdminFromRequest`

These functions are tightly coupled to CMS semantics and must remain isolated.

---

### Implementation Rules

- Lives inside the CMS module
- Not exported to shared Lambda layers
- Can evolve freely with CMS requirements

---

## Layer C — Cross-Domain Capability Layer (SEPARATE STACK)

### Definition

Logic that represents a **business capability** used by multiple domains, where CMS is **only a consumer**, not the owner.

These are **services**, not utilities.

---

### Identification Rules

A function belongs to **Layer C** if:

- CMS and other domains depend on it
- It performs a meaningful business action
- It causes external side effects
- It must scale or fail independently

---

### CMS-Relevant Examples

- Notification services (email, push, in-app)
- OTP generation and delivery
- Media processing pipelines
- Search / indexing services

CMS may **call** these services, but must never embed their logic.

---

### Implementation Rules

- Deployed as a **separate stack**
- Accessed via API or events
- Owned by a shared-services or platform team

---

## Layer D — Isolation Layer (CONCEPTUAL, NOT CODE)

### Definition

An **intentional duplication strategy** where similar logic is written separately for CMS to avoid tight coupling with other domains or platforms.

This is not a folder or Lambda layer.

---

### CMS Examples

- Content filtering logic implemented differently for:
  - Admin APIs
  - Public APIs
- Slightly different validation or transformation rules per consumer
- CMS-specific formatting that looks generic but is not reusable

---

### Identification Rules

Logic belongs conceptually to **Layer D** if:

- It looks reusable
- But behaves differently depending on CMS context
- Or would introduce coupling if shared

---

### Key Rule

✅ Duplication is intentional  
❌ Abstraction is harmful here

---

## CMS Enforcement Rules (MANDATORY)

Before adding or sharing any CMS function, answer:

1. Does this function know CMS entities or rules?
2. Does it shape or validate CMS data?
3. Does it cause business side effects?
4. Would another domain realistically reuse it without modification?

If the answer to **any** is “yes” → it does **not** belong in Layer A.

---

## Summary Table

| Layer   | Scope                | Sharing Allowed  | CMS Role |
| ------- | -------------------- | ---------------- | -------- |
| Layer A | Infra / Technical    | Yes (Global)     | Consumer |
| Layer B | CMS Domain           | No               | Owner    |
| Layer C | Business Capability  | Yes (as Service) | Consumer |
| Layer D | Conceptual Isolation | No               | Owner    |
